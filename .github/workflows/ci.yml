name: Build And Release Pkgs
on:
  workflow_dispatch:
  push:
    paths:
      - '**'
      - '!docs/**'
      - '!.github/**'
      - '!README.md'
    branches:
      - main
  pull_request: 
    paths:
      - '**'
      - '!docs/**'
      - '!.github/**'
      - '!README.md'
    branches: 
      - main

jobs:
  # Discover all Go modules dynamically
  discover:
    name: Discover modules
    runs-on: ubuntu-latest
    outputs:
      modules: ${{ steps.find-modules.outputs.modules }}
    steps:
      - uses: actions/checkout@v4
      - name: Find Go modules
        id: find-modules
        run: |
          # Find all directories containing go.mod, excluding root
          MODULES=$(find . -name "go.mod" -not -path "./go.mod" -exec dirname {} \; | sed 's|^\./||' | sort | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "modules=$MODULES" >> $GITHUB_OUTPUT
          echo "Found modules: $MODULES"

  unit-tests:
    name: unit-test-${{ matrix.module }}
    runs-on: ubuntu-latest
    needs: discover
    strategy:
      fail-fast: false
      matrix:
        module: ${{ fromJson(needs.discover.outputs.modules) }}
    permissions:
      contents: read
      actions: read
      pull-requests: write # needed for coverage comments
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v4
        with:
          go-version: ^1.25
      - name: Test ${{ matrix.module }} module
        working-directory: ${{ matrix.module }}
        run: |
          go mod download
          # Exclude test fixture packages (e.g., loggertest, slippytest) from test and coverage
          PKGS=$(go list ./... | grep -v 'test' || echo "./...")
          go test -cover -coverprofile=../coverage-${{ matrix.module }}.out -covermode=atomic $PKGS
          go tool cover -func=../coverage-${{ matrix.module }}.out
      - name: check ${{ matrix.module }} test coverage
        uses: vladopajic/go-test-coverage@v2
        with:
          profile: ./coverage-${{ matrix.module }}.out
          threshold-total: 75
          source-dir: ./${{ matrix.module }}
      
  lint:
    name: lint-${{ matrix.module }}
    runs-on: ubuntu-latest
    needs: discover
    strategy:
      fail-fast: false
      matrix:
        module: ${{ fromJson(needs.discover.outputs.modules) }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v4
        with:
          go-version: ^1.25
      - name: Install tools
        run: make install-tools
      - name: Lint ${{ matrix.module }} module
        working-directory: ${{ matrix.module }}
        run: |
          go mod tidy
          golangci-lint run --config ../.github/.golangci.yml --timeout 5m ./...
  
  vuln:
    name: check-sec-${{ matrix.module }}
    runs-on: ubuntu-latest
    needs: discover
    strategy:
      fail-fast: false
      matrix:
        module: ${{ fromJson(needs.discover.outputs.modules) }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v4
        with:
          go-version: ^1.25
      - name: Run vulnerability scan on ${{ matrix.module }} module
        run: make check-sec PKG=${{ matrix.module }}

  # Check that all unit tests passed
  unit-tests-check:
    name: "Unit tests status check"
    runs-on: ubuntu-latest
    needs: unit-tests
    if: always()
    steps:
      - name: Check unit test results
        run: |
          echo "Unit tests completed"
          # This job will fail if any of the matrix unit test jobs failed
          if [[ "${{ needs.unit-tests.result }}" != "success" ]]; then
            echo "Some unit tests failed"
            exit 1
          fi
          echo "All unit tests passed"

  # Check that all lint jobs passed  
  lint-check:
    name: "Lint status check"
    runs-on: ubuntu-latest
    needs: lint
    if: always()
    steps:
      - name: Check lint results
        run: |
          echo "Lint jobs completed"
          # This job will fail if any of the matrix lint jobs failed
          if [[ "${{ needs.lint.result }}" != "success" ]]; then
            echo "Some lint jobs failed"
            exit 1
          fi
          echo "All lint jobs passed"

  # Check that all vuln jobs passed
  vuln-check:
    name: "Vulnerability scan status check"
    runs-on: ubuntu-latest
    needs: vuln
    if: always()
    steps:
      - name: Check vulnerability scan results
        run: |
          echo "Vulnerability scan jobs completed"
          # This job will fail if any of the matrix vuln jobs failed
          if [[ "${{ needs.vuln.result }}" != "success" ]]; then
            echo "Some vulnerability scan jobs failed"
            exit 1
          fi
          echo "All vulnerability scan jobs passed"

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: 
      - discover
      - unit-tests-check
      - lint-check
      - vuln-check
    if: github.ref == 'refs/heads/main'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.ref }}
        fetch-depth: 0
    - name: Install GitVersion
      uses: gittools/actions/gitversion/setup@v3.1.11
      with:
        versionSpec: '6.0.x'
    - name: Calculate Version
      id: calculate_version
      uses: gittools/actions/gitversion/execute@v3.1.11
      with:
        useConfigFile: true
        disableCache: true
        configFilePath: .github/Gitversion.yml
    - name: Create and push tags
      id: create_tags
      env:
        MODULES: ${{ needs.discover.outputs.modules }}
        VERSION: ${{ steps.calculate_version.outputs.majorMinorPatch }}
      run: |
        git config user.name "$GITHUB_ACTOR"
        git config user.email "$GITHUB_ACTOR@users.noreply.github.com"
        
        # Create and push main library tag first
        echo "Creating main library tag v$VERSION"
        git tag -a "v$VERSION" -m "Release goLibMyCarrier v$VERSION"
        git push origin "v$VERSION"
        
        # Create and push tags for each module dynamically
        MODULE_LIST=""
        for module in $(echo "$MODULES" | jq -r '.[]'); do
          echo "Creating tag for $module/v$VERSION"
          git tag -a "$module/v$VERSION" -m "Release $module/v$VERSION"
          git push origin "$module/v$VERSION"
          MODULE_LIST="$MODULE_LIST- **$module** - $(head -1 $module/README.md 2>/dev/null | sed 's/^# //' || echo "$module package")\n"
        done
        
        # Store module list for release notes
        echo "module_list<<EOF" >> $GITHUB_OUTPUT
        echo -e "$MODULE_LIST" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
    - name: Generate release body
      id: release_body
      env:
        MODULES: ${{ needs.discover.outputs.modules }}
        VERSION: ${{ steps.calculate_version.outputs.majorMinorPatch }}
      run: |
        # Generate package list for release notes
        PACKAGE_LIST=""
        DOC_LIST=""
        for module in $(echo "$MODULES" | jq -r '.[]'); do
          DESC=$(head -1 "$module/README.md" 2>/dev/null | sed 's/^# //' || echo "$module package")
          PACKAGE_LIST="$PACKAGE_LIST- **$module** - $DESC\n"
          DOC_LIST="$DOC_LIST- [$module](https://pkg.go.dev/github.com/MyCarrier-DevOps/goLibMyCarrier/$module@v$VERSION)\n"
        done
        
        cat << EOF > release_body.md
        # goLibMyCarrier v$VERSION
        
        This release includes updates to all Go packages in the goLibMyCarrier collection.
        
        ## Packages Released
        
        All packages have been tagged with version \`v$VERSION\`:

        $(echo -e "$PACKAGE_LIST")
        
        ## Installation
        
        Install any package using:
        \`\`\`bash
        go get github.com/MyCarrier-DevOps/goLibMyCarrier/<package>@v$VERSION
        \`\`\`
        
        ## Documentation
        
        View package documentation on pkg.go.dev:
        $(echo -e "$DOC_LIST")
        EOF
    - name: Create Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ steps.calculate_version.outputs.majorMinorPatch }}
        release_name: Release v${{ steps.calculate_version.outputs.majorMinorPatch }}
        body_path: release_body.md
        draft: false
        prerelease: false
    
    - name: Refresh pkg.go.dev cache
      env:
        MODULES: ${{ needs.discover.outputs.modules }}
        VERSION: ${{ steps.calculate_version.outputs.majorMinorPatch }}
      run: |
        # Request pkg.go.dev to fetch the new main module version
        echo "Requesting pkg.go.dev refresh for main module v$VERSION"
        curl -s "https://proxy.golang.org/github.com/!my!carrier-!dev!ops/go!lib!my!carrier/@v/v$VERSION.info" || true
        
        # Request pkg.go.dev to fetch each submodule version
        for module in $(echo "$MODULES" | jq -r '.[]'); do
          # Convert module path to Go module proxy format (uppercase letters become !lowercase)
          ENCODED_MODULE=$(echo "$module" | sed 's/\([A-Z]\)/!\L\1/g')
          echo "Requesting pkg.go.dev refresh for $module/v$VERSION"
          curl -s "https://proxy.golang.org/github.com/!my!carrier-!dev!ops/go!lib!my!carrier/$ENCODED_MODULE/@v/v$VERSION.info" || true
        done
        
        # Give the proxy a moment to process, then trigger pkg.go.dev documentation fetch
        sleep 5
        
        # Trigger documentation generation for main module
        echo "Triggering pkg.go.dev documentation for main module"
        curl -s "https://pkg.go.dev/github.com/MyCarrier-DevOps/goLibMyCarrier@v$VERSION" > /dev/null || true
        
        # Trigger documentation generation for each submodule
        for module in $(echo "$MODULES" | jq -r '.[]'); do
          echo "Triggering pkg.go.dev documentation for $module"
          curl -s "https://pkg.go.dev/github.com/MyCarrier-DevOps/goLibMyCarrier/$module@v$VERSION" > /dev/null || true
        done
        
        echo "pkg.go.dev refresh requests completed"
